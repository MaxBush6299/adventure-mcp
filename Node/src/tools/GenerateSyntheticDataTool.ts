import sql from "mssql";
import { Tool } from "@modelcontextprotocol/sdk/types.js";
import { ToolContext, isValidAuthContext } from './ToolContext.js';

/**
 * Tool for generating synthetic test data based on table schema
 * Useful for testing, development, and demonstrating database capabilities
 */
export class GenerateSyntheticDataTool implements Tool {
  [key: string]: any;
  name = "generate_synthetic_data";
  description = `Generates synthetic test data for a specified table based on its schema. 
Automatically detects column types and generates appropriate realistic data. 
Useful for testing Row-Level Security, performance testing, and development environments.`;
  
  inputSchema = {
    type: "object",
    properties: {
      tableName: { 
        type: "string", 
        description: "Table to generate data for (format: 'schema.table' or just 'table' for dbo schema, e.g., 'Sales.Customer', 'dbo.Products')" 
      },
      rowCount: {
        type: "number",
        description: "Number of rows to generate (minimum 1, maximum 10000)",
        minimum: 1,
        maximum: 10000
      },
      dataProfile: {
        type: "string",
        enum: ["realistic", "random", "edge-cases"],
        description: "Type of data to generate: 'realistic' (human-like names, emails, addresses), 'random' (pure random values), 'edge-cases' (nulls, boundary values, special characters)"
      }
    },
    required: ["tableName", "rowCount"],
  } as any;

  async run(params: any, context?: ToolContext) {
    try {
      const { tableName, rowCount = 100, dataProfile = "realistic" } = params;
      
      // Validate row count
      if (rowCount < 1 || rowCount > 10000) {
        return {
          success: false,
          message: "Row count must be between 1 and 10000. For larger datasets, please run multiple batches."
        };
      }
      
      // Parse table name
      const [schema, table] = tableName.includes('.') 
        ? tableName.split('.') 
        : ['dbo', tableName];
      
      let request: sql.Request;
      
      // Get connection pool (per-user if authenticated, global if not)
      if (isValidAuthContext(context) && context) {
        const userId = context.userIdentity.oid || context.userIdentity.userId;
        const userEmail = context.userIdentity.email || context.userIdentity.upn;
        console.log(`[GenerateSyntheticDataTool] Using per-user pool for ${userEmail} (OID: ${userId})`);
        
        const pool = await context.poolManager.getPoolForUser(
          userId,
          context.userIdentity.sqlToken!,
          context.userIdentity.tokenExpiry!
        );
        request = pool.request();
      } else {
        console.log(`[GenerateSyntheticDataTool] Using global pool (no authentication context)`);
        request = new sql.Request();
      }
      
      // Step 1: Verify table exists and get schema
      console.log(`[GenerateSyntheticDataTool] Retrieving schema for ${schema}.${table}`);
      
      const schemaQuery = `
        SELECT 
          c.COLUMN_NAME as name,
          c.DATA_TYPE as type,
          c.CHARACTER_MAXIMUM_LENGTH as maxLength,
          c.IS_NULLABLE as nullable,
          c.COLUMN_DEFAULT as defaultValue,
          COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA + '.' + c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as isIdentity,
          c.NUMERIC_PRECISION as numericPrecision,
          c.NUMERIC_SCALE as numericScale
        FROM INFORMATION_SCHEMA.COLUMNS c
        WHERE c.TABLE_SCHEMA = @schema 
          AND c.TABLE_NAME = @table
        ORDER BY c.ORDINAL_POSITION
      `;
      
      request.input("schema", sql.NVarChar, schema);
      request.input("table", sql.NVarChar, table);
      
      const schemaResult = await request.query(schemaQuery);
      const columns = schemaResult.recordset;
      
      if (columns.length === 0) {
        return {
          success: false,
          message: `Table ${schema}.${table} not found or has no columns. Please verify the table name and schema.`
        };
      }
      
      console.log(`[GenerateSyntheticDataTool] Found ${columns.length} columns in ${schema}.${table}`);
      
      // Step 2: Generate synthetic data
      console.log(`[GenerateSyntheticDataTool] Generating ${rowCount} rows with profile: ${dataProfile}`);
      const syntheticRows: any[] = [];
      
      for (let i = 0; i < rowCount; i++) {
        const row: any = {};
        
        for (const col of columns) {
          // Skip identity columns (auto-generated by database)
          if (col.isIdentity === 1) {
            console.log(`[GenerateSyntheticDataTool] Skipping identity column: ${col.name}`);
            continue;
          }
          
          // Skip columns with defaults in realistic mode (let DB handle them)
          if (col.defaultValue && dataProfile === "realistic") {
            continue;
          }
          
          // Generate value based on data type and column name
          row[col.name] = this.generateValue(col, i, dataProfile);
        }
        
        syntheticRows.push(row);
      }
      
      if (syntheticRows.length === 0 || Object.keys(syntheticRows[0]).length === 0) {
        return {
          success: false,
          message: `Unable to generate data - all columns are either identity or have defaults. Table may be fully auto-generated.`
        };
      }
      
      // Step 3: Insert data in batches
      console.log(`[GenerateSyntheticDataTool] Inserting data in batches of 100`);
      const batchSize = 100;
      let insertedCount = 0;
      
      for (let i = 0; i < syntheticRows.length; i += batchSize) {
        const batch = syntheticRows.slice(i, i + batchSize);
        
        // Create new request for each batch
        let batchRequest: sql.Request;
        if (isValidAuthContext(context) && context) {
          const userId = context.userIdentity.oid || context.userIdentity.userId;
          const pool = await context.poolManager.getPoolForUser(
            userId,
            context.userIdentity.sqlToken!,
            context.userIdentity.tokenExpiry!
          );
          batchRequest = pool.request();
        } else {
          batchRequest = new sql.Request();
        }
        
        const columnNames = Object.keys(batch[0]);
        const valueRows: string[] = [];
        
        // Build parameterized INSERT statement
        batch.forEach((row, idx) => {
          const placeholders = columnNames.map((col, colIdx) => 
            `@val_${i + idx}_${colIdx}`
          ).join(', ');
          valueRows.push(`(${placeholders})`);
          
          // Add parameters for this row
          columnNames.forEach((col, colIdx) => {
            const value = row[col];
            const column = columns.find(c => c.name === col);
            
            // Set appropriate SQL type based on column type
            if (value === null) {
              batchRequest.input(`val_${i + idx}_${colIdx}`, sql.NVarChar, null);
            } else {
              this.addInputParameter(batchRequest, `val_${i + idx}_${colIdx}`, value, column);
            }
          });
        });
        
        const insertQuery = `
          INSERT INTO [${schema}].[${table}] (${columnNames.map(c => `[${c}]`).join(', ')})
          VALUES ${valueRows.join(', ')}
        `;
        
        await batchRequest.query(insertQuery);
        insertedCount += batch.length;
        
        console.log(`[GenerateSyntheticDataTool] Batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(syntheticRows.length / batchSize)} complete (${insertedCount}/${rowCount} rows)`);
      }
      
      console.log(`[GenerateSyntheticDataTool] Successfully inserted ${insertedCount} rows into ${schema}.${table}`);
      
      return {
        success: true,
        message: `Successfully generated and inserted ${insertedCount} synthetic rows into ${schema}.${table}`,
        details: {
          tableName: `${schema}.${table}`,
          rowsGenerated: rowCount,
          rowsInserted: insertedCount,
          dataProfile: dataProfile,
          columnsPopulated: Object.keys(syntheticRows[0]).length,
          batchesProcessed: Math.ceil(syntheticRows.length / batchSize)
        }
      };
      
    } catch (error: any) {
      console.error(`[GenerateSyntheticDataTool] Error:`, error);
      return {
        success: false,
        message: `Failed to generate synthetic data: ${error.message || error}`,
        error: error.toString()
      };
    }
  }
  
  /**
   * Add input parameter with appropriate SQL type
   */
  private addInputParameter(request: sql.Request, paramName: string, value: any, column: any) {
    const type = column.type.toLowerCase();
    
    switch (type) {
      case 'int':
        request.input(paramName, sql.Int, value);
        break;
      case 'bigint':
        request.input(paramName, sql.BigInt, value);
        break;
      case 'smallint':
        request.input(paramName, sql.SmallInt, value);
        break;
      case 'tinyint':
        request.input(paramName, sql.TinyInt, value);
        break;
      case 'decimal':
      case 'numeric':
        request.input(paramName, sql.Decimal(column.numericPrecision, column.numericScale), value);
        break;
      case 'float':
        request.input(paramName, sql.Float, value);
        break;
      case 'real':
        request.input(paramName, sql.Real, value);
        break;
      case 'money':
        request.input(paramName, sql.Money, value);
        break;
      case 'bit':
        request.input(paramName, sql.Bit, value);
        break;
      case 'datetime':
        request.input(paramName, sql.DateTime, value);
        break;
      case 'datetime2':
        request.input(paramName, sql.DateTime2, value);
        break;
      case 'date':
        request.input(paramName, sql.Date, value);
        break;
      case 'time':
        request.input(paramName, sql.Time, value);
        break;
      case 'uniqueidentifier':
        request.input(paramName, sql.UniqueIdentifier, value);
        break;
      case 'nvarchar':
        request.input(paramName, sql.NVarChar(column.maxLength || sql.MAX), value);
        break;
      case 'varchar':
        request.input(paramName, sql.VarChar(column.maxLength || sql.MAX), value);
        break;
      case 'nchar':
        request.input(paramName, sql.NChar(column.maxLength), value);
        break;
      case 'char':
        request.input(paramName, sql.Char(column.maxLength), value);
        break;
      case 'text':
        request.input(paramName, sql.Text, value);
        break;
      case 'ntext':
        request.input(paramName, sql.NText, value);
        break;
      default:
        request.input(paramName, sql.NVarChar, value?.toString());
    }
  }
  
  /**
   * Generate synthetic value based on column metadata
   */
  private generateValue(column: any, index: number, profile: string): any {
    const { type, name, maxLength, nullable } = column;
    const lowerName = name.toLowerCase();
    
    // Handle nullable columns based on profile
    if (nullable === 'YES' && profile === 'edge-cases' && index % 10 === 0) {
      return null; // 10% null values in edge-cases mode
    }
    
    // Type-based generation
    const colType = type.toLowerCase();
    
    switch (colType) {
      case 'int':
      case 'bigint':
      case 'smallint':
      case 'tinyint':
        return this.generateInteger(lowerName, index, profile);
      
      case 'decimal':
      case 'numeric':
      case 'float':
      case 'real':
      case 'money':
        return this.generateDecimal(lowerName, index, profile);
      
      case 'varchar':
      case 'nvarchar':
      case 'char':
      case 'nchar':
      case 'text':
      case 'ntext':
        return this.generateString(lowerName, maxLength, index, profile);
      
      case 'datetime':
      case 'datetime2':
      case 'date':
        return this.generateDate(lowerName, index, profile);
      
      case 'time':
        return this.generateTime(index, profile);
      
      case 'bit':
        return this.generateBoolean(index, profile);
      
      case 'uniqueidentifier':
        return this.generateGuid();
      
      default:
        return `Generated_${index}`;
    }
  }
  
  /**
   * Generate integer values
   */
  private generateInteger(columnName: string, index: number, profile: string): number {
    if (profile === 'edge-cases') {
      const edgeCases = [0, 1, -1, 999999, -999999];
      return edgeCases[index % edgeCases.length];
    }
    
    // Realistic values based on column name
    if (columnName.includes('customerid') || columnName.includes('customer_id')) {
      return 10000 + index;
    }
    if (columnName.includes('age')) {
      return 18 + Math.floor(Math.random() * 70); // 18-88 years
    }
    if (columnName.includes('year')) {
      return 2020 + Math.floor(Math.random() * 5); // 2020-2024
    }
    if (columnName.includes('quantity') || columnName.includes('qty')) {
      return 1 + Math.floor(Math.random() * 100);
    }
    if (columnName.includes('rating') || columnName.includes('score')) {
      return 1 + Math.floor(Math.random() * 5); // 1-5 rating
    }
    
    return Math.floor(Math.random() * 10000);
  }
  
  /**
   * Generate decimal values
   */
  private generateDecimal(columnName: string, index: number, profile: string): number {
    if (profile === 'edge-cases') {
      const edgeCases = [0.00, 0.01, 999.99, -999.99];
      return edgeCases[index % edgeCases.length];
    }
    
    // Realistic values based on column name
    if (columnName.includes('price') || columnName.includes('cost') || columnName.includes('amount')) {
      return parseFloat((Math.random() * 1000).toFixed(2));
    }
    if (columnName.includes('tax') || columnName.includes('discount')) {
      return parseFloat((Math.random() * 100).toFixed(2));
    }
    if (columnName.includes('weight')) {
      return parseFloat((Math.random() * 50).toFixed(2));
    }
    if (columnName.includes('latitude') || columnName.includes('lat')) {
      return parseFloat(((Math.random() * 180) - 90).toFixed(6));
    }
    if (columnName.includes('longitude') || columnName.includes('lon') || columnName.includes('lng')) {
      return parseFloat(((Math.random() * 360) - 180).toFixed(6));
    }
    
    return parseFloat((Math.random() * 1000).toFixed(2));
  }
  
  /**
   * Generate string values
   */
  private generateString(columnName: string, maxLength: number, index: number, profile: string): string {
    const length = Math.min(maxLength || 50, 200);
    
    if (profile === 'edge-cases') {
      const edgeCases = ['', 'A', 'a'.repeat(Math.min(length, 10)), `Test'Quote"`, 'null', 'undefined'];
      return edgeCases[index % edgeCases.length];
    }
    
    // Realistic values based on column name
    if (profile === 'realistic') {
      // Names
      if (columnName.includes('firstname') || columnName.includes('first_name') || columnName.includes('fname')) {
        const names = ['James', 'Mary', 'John', 'Patricia', 'Robert', 'Jennifer', 'Michael', 'Linda', 
                       'William', 'Barbara', 'David', 'Elizabeth', 'Richard', 'Susan', 'Joseph', 'Jessica',
                       'Thomas', 'Sarah', 'Charles', 'Karen', 'Christopher', 'Nancy', 'Daniel', 'Lisa'];
        return names[index % names.length];
      }
      
      if (columnName.includes('lastname') || columnName.includes('last_name') || columnName.includes('lname')) {
        const names = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis',
                       'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Gonzalez', 'Wilson', 'Anderson',
                       'Thomas', 'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee', 'Perez', 'Thompson'];
        return names[index % names.length];
      }
      
      if (columnName.includes('middlename') || columnName.includes('middle_name')) {
        const names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M'];
        return names[index % names.length];
      }
      
      // Contact information
      if (columnName.includes('email')) {
        const domains = ['example.com', 'test.com', 'demo.com', 'sample.org', 'company.net'];
        return `user${index}@${domains[index % domains.length]}`;
      }
      
      if (columnName.includes('phone') || columnName.includes('telephone') || columnName.includes('mobile')) {
        const areaCode = 200 + Math.floor(Math.random() * 800);
        const prefix = 200 + Math.floor(Math.random() * 800);
        const lineNum = 1000 + Math.floor(Math.random() * 9000);
        return `${areaCode}-${prefix}-${lineNum}`;
      }
      
      // Addresses
      if (columnName.includes('address') || columnName.includes('street')) {
        const numbers = 100 + Math.floor(Math.random() * 9900);
        const streets = ['Main St', 'Oak Ave', 'Maple Dr', 'Park Ln', 'Washington Blvd', 'Lake Rd', 'Cedar Way'];
        return `${numbers} ${streets[index % streets.length]}`;
      }
      
      if (columnName.includes('city')) {
        const cities = ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Philadelphia', 
                       'San Antonio', 'San Diego', 'Dallas', 'San Jose', 'Austin', 'Jacksonville',
                       'Fort Worth', 'Columbus', 'Charlotte', 'San Francisco', 'Indianapolis', 'Seattle'];
        return cities[index % cities.length];
      }
      
      if (columnName.includes('state') || columnName.includes('province')) {
        const states = ['CA', 'TX', 'FL', 'NY', 'PA', 'IL', 'OH', 'GA', 'NC', 'MI', 'NJ', 'VA', 'WA', 'AZ', 'MA'];
        return states[index % states.length];
      }
      
      if (columnName.includes('zip') || columnName.includes('postal')) {
        return String(10000 + Math.floor(Math.random() * 90000)).padStart(5, '0');
      }
      
      if (columnName.includes('country')) {
        const countries = ['USA', 'Canada', 'UK', 'Germany', 'France', 'Spain', 'Italy', 'Australia', 'Japan'];
        return countries[index % countries.length];
      }
      
      // Business information
      if (columnName.includes('company') || columnName.includes('organization')) {
        const companies = ['Acme Corp', 'TechStart Inc', 'Global Solutions', 'Innovation Labs', 
                          'Digital Ventures', 'Prime Industries', 'Apex Systems', 'NextGen Tech'];
        return companies[index % companies.length];
      }
      
      if (columnName.includes('title') || columnName.includes('jobtitle') || columnName.includes('position')) {
        const titles = ['Manager', 'Director', 'Engineer', 'Analyst', 'Coordinator', 'Specialist', 
                       'Consultant', 'Administrator', 'Developer', 'Designer'];
        return titles[index % titles.length];
      }
      
      if (columnName.includes('department') || columnName.includes('dept')) {
        const departments = ['Sales', 'Marketing', 'Engineering', 'HR', 'Finance', 'Operations', 'IT', 'Support'];
        return departments[index % departments.length];
      }
      
      // Products/Items
      if (columnName.includes('product') || columnName.includes('item')) {
        return `Product-${String(index).padStart(4, '0')}`;
      }
      
      if (columnName.includes('sku') || columnName.includes('code')) {
        return `SKU-${String(index).padStart(6, '0')}`;
      }
      
      if (columnName.includes('description') || columnName.includes('notes') || columnName.includes('comment')) {
        const descriptions = [
          'High quality product with excellent features',
          'Standard model suitable for everyday use',
          'Premium version with advanced capabilities',
          'Entry level option for budget-conscious buyers',
          'Professional grade equipment for demanding applications'
        ];
        return descriptions[index % descriptions.length];
      }
      
      if (columnName.includes('status')) {
        const statuses = ['Active', 'Pending', 'Completed', 'Cancelled', 'In Progress'];
        return statuses[index % statuses.length];
      }
      
      if (columnName.includes('category') || columnName.includes('type')) {
        const categories = ['Type A', 'Type B', 'Type C', 'Standard', 'Premium', 'Basic', 'Advanced'];
        return categories[index % categories.length];
      }
    }
    
    // Random string fallback
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    const targetLength = Math.min(length, 20);
    for (let i = 0; i < targetLength; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result || `Value_${index}`;
  }
  
  /**
   * Generate date values
   */
  private generateDate(columnName: string, index: number, profile: string): Date {
    const now = new Date();
    
    if (profile === 'edge-cases') {
      const edgeCases = [
        new Date('1900-01-01'),
        new Date('1970-01-01'),
        new Date('2000-01-01'),
        now,
        new Date('2099-12-31')
      ];
      return edgeCases[index % edgeCases.length];
    }
    
    // Realistic dates based on column name
    if (columnName.includes('birth') || columnName.includes('dob')) {
      // Birth dates: 18-80 years ago
      const yearsAgo = 18 + Math.floor(Math.random() * 62);
      const date = new Date(now.getFullYear() - yearsAgo, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1);
      return date;
    }
    
    if (columnName.includes('created') || columnName.includes('registered') || columnName.includes('joined')) {
      // Recent dates: last 2 years
      const daysAgo = Math.floor(Math.random() * 730);
      return new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000);
    }
    
    if (columnName.includes('modified') || columnName.includes('updated') || columnName.includes('changed')) {
      // Very recent: last 90 days
      const daysAgo = Math.floor(Math.random() * 90);
      return new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000);
    }
    
    if (columnName.includes('expire') || columnName.includes('expiration') || columnName.includes('end')) {
      // Future dates: next 1-5 years
      const daysAhead = Math.floor(Math.random() * 1825);
      return new Date(now.getTime() + daysAhead * 24 * 60 * 60 * 1000);
    }
    
    // Default: random date within last year
    const daysAgo = Math.floor(Math.random() * 365);
    return new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000);
  }
  
  /**
   * Generate time values
   */
  private generateTime(index: number, profile: string): Date {
    if (profile === 'edge-cases') {
      const times = ['00:00:00', '12:00:00', '23:59:59'];
      return new Date(`1970-01-01T${times[index % times.length]}`);
    }
    
    // Business hours: 8 AM - 6 PM
    const hour = 8 + Math.floor(Math.random() * 10);
    const minute = Math.floor(Math.random() * 60);
    const second = Math.floor(Math.random() * 60);
    return new Date(`1970-01-01T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`);
  }
  
  /**
   * Generate boolean values
   */
  private generateBoolean(index: number, profile: string): number {
    if (profile === 'edge-cases') {
      return index % 2; // Alternating 0 and 1
    }
    return Math.random() > 0.5 ? 1 : 0;
  }
  
  /**
   * Generate GUID values
   */
  private generateGuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
}
